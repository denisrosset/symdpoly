  /*
  override def evaluator(equivalences0: evaluation.Equivalence[self.type]*): Evaluator.Aux[self.type] = {
    val transformed: Vector[Option[freebased.Equivalence[self.type, Free]]] = equivalences0.toVector.map {
      case freeBased: freebased.Equivalence[self.type, Free] =>
        Some(freeBased)
      case adjoint: AdjointEquivalence[self.type] =>
        Some(new freebased.AdjointEquivalence[self.type, Free])
      case symmetry: generic.SymmetryEquivalence[self.type, groupType] if symmetry.action.isInstanceOf[PermutationMonoAction[self.type, Free]] =>
        val grp = symmetry.grp.asInstanceOf[Grp[freebased.Permutation[self.type, Free]]]
        Some(new freebased.SymmetryEquivalence(grp))
      case _ =>
        None
    }
    val freeBasedEquivalences: Option[Vector[freebased.Equivalence[self.type, Free]]] = transformed.sequence
    freeBasedEquivalences match {
      case Some(freeBasedEqs) => new {
        val equivalences: Seq[evaluation.Equivalence[self.type]] = freeBasedEqs
        implicit val witnessMono: Witness.Aux[self.type] = self.witness
      } with Evaluator {
        type Mono = self.type
      }
      case None => new {
        val equivalences: Seq[evaluation.Equivalence[self.type]] = equivalences0
        implicit val witnessMono: Witness.Aux[self.type] = self.witness
      } with Evaluator {
        type Mono = self.type
      }
    }
    // freebased.Evaluator[self.type, Free](equivalences)
    */
