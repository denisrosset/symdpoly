  val doubleSized: Morphism[GenPerm, GenPerm, Group] = Morphism({ g =>
    def doubledAction(i2: Int): Int = g.perm.image(i2/2) * 2 + (i2%2)
    val perm2 = Perm.fromImageFun(g.largestMovedPoint.getOrElse(-1) + 1, doubledAction(_))
    val phases2 = Phases(g.phases.elements.toSeq.flatMap { case (k, v) => Seq(k*2 -> v, k*2 + 1 -> v) }: _*)
    GenPerm(perm2, phases2)
  })


/*
  /*
  def forceComplexEncoding: Block = {
    require(!hasComplexEncoding)
    Block(size * 2, basisSize, true,
      basisIndices.flatMap(i => Array(i, i)),
      rowIndices.flatMap(r => Array(r, r)),
      colIndices.flatMap(c => Array(c, c)),
      coefficients.flatMap(e => Array(e, e)),
      symmetry
    )
  }*/

  /*
  def realDoubleRepresentation: Morphism[Perm, Mat[Double], Monoid] = {
    val n = if (hasComplexEncoding) size * 2 else size
    implicit val monoid: Monoid[Mat[Double]] = new Monoid[Mat[Double]] {
      def empty: Mat[Double] = Mat.eye[Double](n)
      def combine(x: Mat[Double], y: Mat[Double]): Mat[Double] = x * y
    }
    def realPhase(phase: Phase): Double = if (phase.isOne) 1.0 else if (phase.isMinusOne) -1.0 else sys.error(s"Invalid real phase $phase")
    def genPermToMatrix(g: GenPerm): Mat[Double] =
      if (!hasComplexEncoding) g.toDoubleMatrixRealPhase(n) else {

      }
    hasComplexEncoding match {
      case false => Mat.sparse(n, n)(Vec(g.perm.images(n): _*), Vec(0 until n: _*), Vec.tabulate(n)(i => realPhase(g.phases.phaseFor(g.perm.image(i)))))
      case
    val rows = Vec(g.perm.images(n): _*)
    val cols = Vec(0 until n: _*)
    val data: Vec[Double] = Vec.tabulate(n) { i =>
    val phase = phases.phaseFor(perm.image(i))

    }
    Mat.sparse(n, n)(rows, cols, data)
      case true =>
        import genPerm.{perm, phases}
        val triplets = (0 until n * 2).flatMap { i =>
          val r = perm.image(i)
          val c = i
          val e = phaseValue(phases.phaseFor(r))
          Seq((r * 2, c * 2, e.real), (r * 2, c * 2 + 1, -e.imag),
            (r * 2 + 1, c * 2, e.imag), (r * 2 + 1, c * 2 + 1, e.real)
          ).filterNot(_._3 == 0)
        }
        val (rows, cols, coeffs) = triplets.unzip3
        Mat.sparse(n * 2, n * 2)(Vec(rows: _*), Vec(cols: _*), Vec(coeffs: _*))
    }

  }
*/

 */